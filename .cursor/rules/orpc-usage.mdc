---
description: oRPC 使用指南 - 包含最佳实践、代码示例和项目约定
---
# oRPC 使用指南

本指南包含了在项目中使用 oRPC 的约定和最佳实践。这些规则旨在保持代码的一致性、可维护性和高性能。

## Procedure (程序)

Procedure 是 oRPC 的基本构建块，类似于一个带有输入/输出验证、中间件和依赖注入等功能的超强函数。

### 基本结构

一个典型的 procedure 定义如下：

```typescript
import { os } from '@orpc/server'
import { z } from 'zod'

const example = os
  .use(aMiddleware) // 应用中间件
  .input(z.object({ name: z.string() })) // 定义输入校验
  .use(aMiddlewareWithInput, input => input.name) // 应用带类型输入的中间件
  .output(z.object({ id: z.number() })) // 定义输出校验
  .handler(async ({ input, context }) => { // 定义执行逻辑
    return { id: 1 }
  })
  .callable() // 使 procedure 可以像普通函数一样调用
  .actionable() // 兼容 Server Action
```

**关键实践:**
- **`.handler` 是必须的**: 每个 procedure 必须有一个 `.handler` 来定义其核心逻辑。
- **显式校验**: 强烈建议为所有 procedure 定义 `.input` 和 `.output`，并使用 `zod` 进行模式校验。这能提供强大的类型安全和自动生成的文档。
- **Procedure 位置**: 所有的 procedure 文件都应放在 [`orpc/procedures/`](mdc:orpc/procedures/) 目录下，并按功能进行划分。例如: [`orpc/procedures/media.ts`](mdc:orpc/procedures/media.ts)。

## Router (路由)

Router 是 procedure 的集合，可以进行嵌套和扩展，用于组织你的 API 端点。

### 定义 Router

Router 是一个简单的 JavaScript 对象，它的键是路由路径，值是 procedure 或其他 router。

```typescript
import { os } from '@orpc/server'

const ping = os.handler(async () => 'ping')
const pong = os.handler(async () => 'pong')

const healthRouter = {
  ping,
  pong,
}

const mainRouter = {
  health: healthRouter, // 嵌套路由
  // ... other procedures
}
```

### 懒加载 (Lazy Loading)

为了优化冷启动性能和实现代码分割，项目强制使用 `os.lazy` 来懒加载 procedure 模块。

**示例:**
查看项目中的主路由文件 [`orpc/router.ts`](mdc:orpc/router.ts)，所有 procedure 模块都是懒加载的。

```typescript
// orpc/router.ts
import { os } from '@orpc/server'

export const appRouter = {
  media: os.lazy(() => import('./procedures/media')),
  comment: os.lazy(() => import('./procedures/comment')),
  // ... 其他懒加载的 procedures
}

export type AppRouter = typeof appRouter
```

## Middleware (中间件)

中间件用于在 procedure 执行前后执行代码，常用于认证、日志、错误处理等横切关注点。

### 定义中间件

一个中间件是一个异步函数，它接收执行上下文 `context` 和一个 `next` 函数。必须调用 `next()` 来将控制权传递给下一个中间件或 procedure handler。

```typescript
import { os } from '@orpc/server'

const authMiddleware = os.middleware(async ({ context, next }) => {
  // 在 handler 执行前的逻辑
  if (!context.user) {
    throw new Error('UNAUTHORIZED');
  }

  // 通过 next() 向下游传递增强的 context
  const result = await next({
    context: {
      user: { ...context.user, role: 'admin' }
    }
  })

  // 在 handler 执行后的逻辑
  return result
})
```

### 使用中间件

在 procedure 或整个 router 上使用 `.use()` 方法来应用中间件。

```typescript
// 应用于单个 procedure
const protectedProcedure = os
  .use(authMiddleware)
  .handler(async ({ context }) => { ... })

// 应用于整个 router
const protectedRouter = os.use(authMiddleware).router({
  // ... procedures
})
```

## Context (上下文)

Context 是一个在请求生命周期内（从中间件到 handler）共享的对象。它用于传递数据库连接、用户信息等依赖。

### 创建初始 Context

初始 Context 在 API 入口处创建，并通过 `createContext` 函数提供给 orpc handler。

**示例:**
在 [`app/api/orpc/[...slug]/route.ts`](mdc:app/api/orpc/[...slug]/route.ts) 中配置 `createContext`。

```typescript
// app/api/orpc/[...slug]/route.ts
import { orpc } from '@orpc/server/http'
import { appRouter } from '~/orpc/router'
import { createContext } from '~/orpc/context' // 假设 context.ts 存在

const handler = orpc({
  router: appRouter,
  createContext, // 传递创建 context 的函数
})

export { handler as GET, handler as POST }
```

一个典型的 `createContext` 函数如下：
```typescript
// orpc/context.ts
import { db } from '~/lib/db'
// import { getAuthSession } from '~/lib/auth'

export async function createContext() {
  // const session = await getAuthSession()
  return {
    // user: session?.user,
    db,
  }
}
```

## 文件上传与下载

oRPC 支持直接处理文件流。

### 文件上传

Procedure 的输入可以是 `FormData`，从而处理文件上传。

```typescript
import { os } from '@orpc/server'
import { z } from 'zod'

export const uploadFile = os
  .input(z.instanceof(FormData))
  .handler(async ({ input }) => {
    const file = input.get('file') as File;
    // ... 文件处理逻辑 ...
    return { success: true, fileName: file.name };
  });
```

### 文件下载

Procedure 可以返回一个标准的 `Response` 对象来实现文件下载。

```typescript
import { os } from '@orpc/server'
import { z } from 'zod'

export const downloadFile = os
  .input(z.object({ fileId: z.string() }))
  .handler(async ({ input }) => {
    const file = await getFileFromStorage(input.fileId); // 假设的函数
    const headers = new Headers();
    headers.set('Content-Type', 'application/octet-stream');
    headers.set('Content-Disposition', `attachment; filename="${file.name}"`);

    return new Response(file.stream(), { headers });
  });
```
